--  ★DDL, DML, DCL
--  SQL = DDL (테이블 생성CREATE, 테이블 삭제DROP, 테이블 구조변경ALTER)
--	1. 테이블 생성 (CRAETE TABLE)
CREATE TABLE BOOK (
	BOOKID NUMBER (4),
	BOOKNAME VARCHAR2 (20),
	PUBLISHER VARCHAR2 (20),
	RDATE DATE, -- 출판일 RDATE타입은 DATE형
	PRICE NUMBER (8),
	PRIMARY KEY (BOOKID) -- 테이블 내 주키, NOT NULL이어야 함.
	);
	
SELECT *
	FROM BOOK;
	
DROP TABLE BOOK;

CREATE TABLE BOOK (
	BOOKID NUMBER (4) PRIMARY KEY,
	BOOKNAME VARCHAR2 (100),
	PUBLISHER VARCHAR2 (20),
	RDATE DATE,
	PRICE NUMBER (8)
);

SELECT *
	FROM BOOK;

--	EMP와 유사한 EMP01 : EMPNO(숫자4), ENAME(문자20), SAL(숫자7,2)
CREATE TABLE EMP01 (
	EMPNO NUMBER (4),
	ENAME VARCHAR2 (20),
	SAL NUMBER(7, 2) -- 전체 7자리 XXXXX.XX
);

SELECT *
	FROM EMP01;

--	DEPT와 유사한 DEPT01 : DEPTNO(숫자2), DNAME(문자14), LOC(문자13)
CREATE TABLE DEPT01 (
	DEPTNO NUMBER (2) PRIMARY KEY,
	DNAME VARCHAR2 (14),
	LOC VARCHAR2 (13)
);

SELECT *
	FROM DEPT01;

--	서브쿼리를 이용한 테이블 생성
CREATE TABLE EMP02
	AS
	SELECT *
		FROM EMP; -- 서브쿼리 결과만 EMP02 테이블 생성 후 들어감 (제약조건 미포함)

--	EMP03 : EMP테이블에서 EMPNO, ENAME, DEPTNO만 추출
CREATE TABLE EMP03
	AS
	SELECT EMPNO, ENAME, DEPTNO
		FROM EMP;

SELECT *
	FROM EMP03;
	
--	EMP04 : EMP테이블에서 10번부서만 추출
CREATE TABLE EMP04
	AS
	SELECT *
		FROM EMP
		WHERE DEPTNO = 10;
	
SELECT *
	FROM EMP04;

--	EMP05 : EMP테이블의 구조만 추출
CREATE TABLE EMP05
	AS
	SELECT *
		FROM EMP
		WHERE 1 = 0;

SELECT *
	FROM EMP05;

SELECT ROWNUM, EMPNO, ENAME
	FROM EMP; -- 행의 논리적 순서(읽어들인 순서)

SELECT ROWID, EMPNO, ENAME
	FROM EMP;



--	2. 테이블 구조 변경 (ALTER TABLE)
--	 1) 필드 추가
SELECT *
	FROM EMP03;

ALTER TABLE EMP03
	ADD (JOB VARCHAR2 (20), SAL NUMBER (7, 2));

SELECT *
	FROM EMP03;

ALTER TABLE EMP03
	ADD (COMM NUMBER (7, 2));

--	 2) 필드 수정 (MODIFY)
ALTER TABLE EMP03
	MODIFY (EMPNO VARCHAR2 (5)); -- 에러남(이미 숫자데이터가 들어있기 때문)
	
ALTER TABLE EMP03
	MODIFY (ENAME VARCHAR2 (20));

ALTER TABLE EMP03
	MODIFY (ENAME VARCHAR2 (8));

ALTER TABLE EMP03
	MODIFY (ENAME VARCHAR2 (5)); -- 불가능
	
SELECT MAX(LENGTH(ENAME)) -- 제일 긴 이름의 바이트 수 : 6
	FROM EMP;

ALTER TABLE EMP03
	MODIFY (JOB VARCHAR2 (3)); -- NULL이면 다 바꿀 수 있음

ALTER TABLE EMP03 
	MODIFY (JOB NUMBER (4));

ALTER TABLE EMP03 
	MODIFY (JOB VARCHAR2 (30)); -- VARCHAR2는 4000이 최대

--	 3) 필드 삭제 (조심)
ALTER TABLE EMP03
	DROP COLUMN JOB; -- NULL인 필드 삭제

SELECT *
	FROM EMP03;

ALTER TABLE EMP03 
	DROP COLUMN DEPTNO; -- DEPTNO 필드 삭제시 데이터까지 제거

--	낮에는 논리적으로 특정 필드를 접근 못하도록
ALTER TABLE EMP03 
	SET UNUSED (COMM);

--	늦은 밤에 접근 불가했던 필드를 삭제
ALTER TABLE EMP03
	DROP UNUSED COLUMNS;

SELECT *
	FROM EMP03;



--	3. 테이블 삭제 (DROP TABLE)
DROP TABLE EMP01;

SELECT *
	FROM DEPT;

DROP TABLE DEPT;

SELECT *
	FROM EMP;

SELECT *
	FROM DEPT; -- 다른 테이블에서 참조한느 데이터가 있을 경우 DROP 불가


	
--	4. 테이블의 모든 행을 제거 (TRUNCATE)
SELECT *
	FROM EMP03;

TRUNCATE TABLE EMP03;



--	5. 테이블 명 변경 (RENAME)
SELECT *
	FROM EMP02;

RENAME EMP02
	TO EMP2; -- 한번 변경하면 복구 불가

SELECT *
	FROM EMP2;



--	6. 데이터 사전 VS 데이터 사전 뷰
--	 종류
--	  1) USER_XXX : 현 계정이 소유하고 있는 객체들 확인 가능
--			USER_TABLES, USER_INDEXES, USER_CONSTRAINTS, USER_VIEWS...
SELECT *
	FROM USER_TABLES;

SELECT *
	FROM USER_INDEXES;

SELECT *
	FROM USER_CONSTRAINTS;

SELECT *
	FROM USER_VIEWS;

--	  2) ALL_XXX : 현 계정이 접근 가능한 모든 객체 확인 가능
--			ALL_TABLES, ALL_INDEXES, ALL_CONSTRAINTS, ALL_VIEWS...
SELECT *
	FROM ALL_TABLES
	WHERE TABLE_NAME = 'EMP';

SELECT *
	FROM ALL_INDEXES;

SELECT *
	FROM ALL_CONSTRAINTS;

SELECT *
	FROM ALL_VIEWS;

--	  3) DBA_XXX : DBA만 접근 가능, DBMS의 모든 객체 확인 가능
--			DBA_TABLES, DBA_INDEXES, DBA_CONSTRAINTS, DBA_VIEWS...
SELECT *
	FROM DBA_TABLES;



--            DCL (사용자계정 생성, 사용자에게 권한부여, 계정삭제, 권한삭제)
--	7. DCL(사용자 계정 생성 및 삭제, 권한 부여 및 삭제)
--	 1) 계정 생성
CREATE USER JOEUN
	IDENTIFIED BY TIGER;

--	 2) 권한 부여(세션, SCOTT.EMP, SCOTT.DEPT에 대한 모든 권한)
--		SELECT * FROM DBA_TABLES; <- 일반 계정에서는 불가
GRANT CREATE SESSION
	TO JOEUN;

GRANT ALL ON EMP
	TO JOEUN; -- EMP테이블에 대한 모든 권한 부여

GRANT SELECT ON DEPT
	TO JOEUN; -- DEPT테이블에 대한 SELECT 권한 부여

--	 3) 권한 박탈 (ID가 접속해제 중)
REVOKE ALL ON EMP
	FROM JOEUN;

REVOKE ALL ON DEPT
	FROM JOEUN;

--	 4) 계정 삭제
DROP USER JOEUN CASCADE;



--            DML (SELECT, INSERT, UPDATE, DELETE)
--	1. INSERT : INSERT INTO TABLENAME VALUES (값1, 값2....)
--		INSERT INTO TABLENAME (FIELD1, FIELD2,.....) VALUES (값1, 값2.....)
SELECT *
	FROM DEPT01;

INSERT INTO DEPT01
	VALUES (50, 'ACCOUNT', 'SEOUL');

INSERT INTO DEPT01 (DEPTNO, DNAME, LOC)
	VALUES (70, 'SALES', 'INCHEON');

INSERT INTO DEPT01 (DNAME, LOC, DEPTNO)
	VALUES ('IT', NULL, 80); -- 명시적으로 NULL 추가

INSERT INTO DEPT01 (DEPTNO, DNAME)
	VALUES (40, 'OPERATION'); -- 묵시적으로 NULL 추가
--		서브쿼리를 이용한 INSERT
--		 DEPT테이블에서 10~30번 부서를 한번에 INSERT 
TRUNCATE TABLE DEPT01;

INSERT INTO DEPT01 
	SELECT *
		FROM DEPT
		WHERE DEPTNO < 40;

SELECT *
	FROM DEPT01;
--		BOOK 테이블에서 11(책번호), '스포츠의학', '한솔출판', 출판일은 오늘, 가격9만원
SELECT *
	FROM BOOK;

INSERT INTO BOOK
	VALUES (11, '스포츠의학', '한솔출판', SYSDATE, 90000);

--	2. UPDATE : UPDATE TABLENAME SET 필드명1 = 값1[, 필드명2 = 값2....] [WHERE조건];
DROP TABLE EMP01;

CREATE TABLE EMP01
	AS
	SELECT *
		FROM EMP;

--	 부서 번호를 30번으로 수정
UPDATE EMP01 SET DEPTNO = 30;	

ROLLBACK;

SELECT *
	FROM EMP01;
--	 모든 직원의 급여를 10% 인상
UPDATE EMP01 SET SAL = SAL*1.1;

SELECT *
	FROM EMP01;

--	 10번 부서의 직원의 입사일을 오늘로, 부서번호는 30번으로 수정하시오.
UPDATE EMP01
	SET HIREDATE = SYSDATE, DEPTNO = 30 
	WHERE DEPTNO = 10;

SELECT *
	FROM EMP01;

--	 SAL이 3000이상인 사원만 급여를 10%인상
UPDATE EMP01
	SET SAL = SAL*1.1
	WHERE SAL >= 3000;

--	 'DALLAS'에 근무하는 직원의 급여를 1000$씩 인상
UPDATE EMP01
	SET SAL = SAL + 1000
	WHERE DEPTNO = (SELECT DEPTNO
										FROM DEPT
											WHERE LOC = 'DALLAS');

SELECT *
	FROM EMP01;

--	 'SCOTT'의 부서번호는 20으로, JOB은 MANAGER, SAL과 COMM을 500$씩 인상
UPDATE EMP01
	SET		JOB = 'MANAGER',
				DEPTNO = 20,
				COMM = NVL(COMM, 0) + 500,
				SAL = SAL + 500,
				MGR = (SELECT EMPNO FROM EMP WHERE ENAME = 'KING')
	WHERE ENAME = 'SCOTT';

SELECT *
	FROM EMP01;

--	 DEPT01 테이블에서 20번부서의 지역명을 60번부서의 지역명으로 변경
UPDATE DEPT01
	SET		LOC = (SELECT LOC
								FROM DEPT01
								WHERE DEPTNO = 60)
	WHERE DEPTNO = 20;

SELECT *
	FROM DEPT01;

--	 EMP01 테이블에서 모든 사원의 급여와 입사일을 'KING'의 급여와 입사일로 수정
UPDATE EMP01
	SET SAL = (SELECT SAL FROM EMP01 WHERE ENAME = 'KING'),
			HIREDATE = (SELECT HIREDATE FROM EMP01 WHERE ENMAE = 'KING');

UPDATE EMP01
	SET (SAL, HIREDATE)  = (SELECT SAL, HIREDATE FROM EMP01 WHERE ENAME = 'KING');

SELECT *
	FROM EMP01;

COMMIT;

--	3. DELETE : DELETE FROM TABLENAME WHERE 조건
SELECT *
	FROM EMP01;

DELETE FROM EMP01;

ROLLBACK;

--	 EMP01 테이블에서 30번 부서의 직원만 삭제
DELETE FROM EMP01 
	WHERE DEPTNO = 30;

--	 EMP01 테이블에서 사원명이 'FORD'인 사원을 삭제
DELETE FROM EMP01
	WHERE ENAME = 'FORD';

--	 SAM01 테이블에서 JOB이 정해지지 않은 사원 삭제
DELETE FROM SAM01 
	WHERE JOB IS NULL;

--	 EMP01 테이블에서 부서명(DNAME)이 'SALES'인 사원 삭제
DELETE FROM EMP01
	WHERE DEPTNO = (SELECT DEPTNO
											FROM DEPT
											WHERE DNAME = 'SALES');

--	 EMP01 테이블에서 RESEARCH 부서 소속인 사원을 삭제
DELETE FROM EMP01
	WHERE DEPTNO = (SELECT DEPTNO
											FROM DEPT
											WHERE DNAME = 'RESEARCH');



--            TCL 트랜잭션 명령어 (COMMIT, ROLLBACK)
COMMIT;
ROLLBACK;



-- ◎ 연습문제 1
DROP TABLE SAM01;

CREATE TABLE SAM01 (
	EMPNO NUMBER (4) PRIMARY KEY,
	ENAME VARCHAR2 (10),
	JOB VARCHAR2 (9),
	SAL NUMBER (7, 2)
);

SELECT *
	FROM SAM01;

INSERT INTO SAM01
	VALUES (1000, 'APPLE', 'POLICE', 10000);

INSERT INTO SAM01
	VALUES (1010, 'BANANA', 'NURESE', 15000);

INSERT INTO SAM01
	VALUES (1020, 'ORAGNE', 'DOCTER', 25000);

INSERT INTO SAM01 (EMPNO, ENAME, SAL)
	VALUES (1030, 'VERY', 10000);

INSERT INTO SAM01 (EMPNO, ENAME, SAL)
	VALUES (1040, 'CAT', 10000);

INSERT INTO SAM01 
	SELECT EMPNO, ENAME, JOB, SAL
		FROM EMP
		WHERE DEPTNO = 10;



--	◆연습문제 2
--		1. 테이블 생성
CREATE TABLE MY_DATA (
	ID NUMBER (4) PRIMARY KEY,
	NAME VARCHAR (10),
	USERID VARCHAR (30),
	SALARY NUMBER (10, 2)
);
	
INSERT INTO MY_DATA
	VALUES (1, 'Scott', 'sscott', 10000.00);
	
INSERT INTO MY_DATA
	VALUES (2, 'Ford', 'fford', 13000.00);	
	
INSERT INTO MY_DATA
	VALUES (3, 'Patel', 'ppatel', 33000.00);	
	
INSERT INTO MY_DATA
	VALUES (4, 'Report', 'rreport', 23500.00);	
	
INSERT INTO MY_DATA
	VALUES (5, 'Good', 'ggood', 445000.00);	
	
SELECT *
	FROM MY_DATA;
	
COMMIT;	
	
UPDATE MY_DATA
	SET SALARY = 65000
	WHERE ID = 3;
	
COMMIT;

DELETE FROM MY_DATA 
	WHERE INITCAP(NAME) = 'Ford';
	
COMMIT;

UPDATE MY_DATA 
	SET SALARY = 15000
	WHERE SALARY = (SELECT SALARY
										FROM MY_DATA
										WHERE SALARY <= 15000);
	
DROP TABLE MY_DATA;
	


--	◆연습문제 2
--		1. 테이블 생성
CREATE TABLE MY_DATA (
	ID NUMBER (4) PRIMARY KEY,
	NAME VARCHAR (10),
	USERID VARCHAR (30),
	SALARY NUMBER (10, 2)
);
	
INSERT INTO MY_DATA
	VALUES (1, INITCAP('Scott'), 'sscott', 10000.00);
	
INSERT INTO MY_DATA
	VALUES (2, 'Ford', 'fford', 13000.00);	
	
INSERT INTO MY_DATA
	VALUES (3, 'Patel', 'ppatel', TO_NUMBER('33,000.00', '99,999.99'));	
	
INSERT INTO MY_DATA
	VALUES (4, 'Report', 'rreport', 23500.00);	
	
INSERT INTO MY_DATA
	VALUES (5, 'Good', 'ggood', 44500.00);	
	
SELECT *
	FROM MY_DATA;
	
COMMIT;	
	
UPDATE MY_DATA
	SET SALARY = 65000
	WHERE ID = 3;
	
COMMIT;

DELETE FROM MY_DATA 
	WHERE NAME = 'Ford';
	
COMMIT;

UPDATE MY_DATA 
	SET SALARY = 15000
	WHERE SALARY = (SELECT SALARY
										FROM MY_DATA
										WHERE SALARY <= 15000);
	
DROP TABLE MY_DATA;
	
	
	
--	※ 제약조건
--	 1) PRIMARY KEY : 유일하게 테이블 각 행을 식별
--	 2) NOT NULL : NULL 값을 포함하지 않음
--	 3) UNIQUE : 모든 행에 대해 유일하지만, NULL 허용
--	 4) FOREIGN KEY : 테이블의 열은 다른 테이블의 열을 참조
--	 5) CHECK : 해당 조건이 만족
--	 6) DEFAULT : 기본 값 설정

CREATE TABLE DEPT1 (
	DEPTNO	NUMBER (2) PRIMARY KEY,
	DNAME	VARCHAR2 (14) UNIQUE,
	LOC		VARCHAR2 (13) NOT NULL
);

SELECT *
	FROM DEPT1;

CREATE TABLE DEP1 (
	DEPTNO NUMBER (2),
	DNAME	VARCHAR2 (14),
	LOC		VARCHAR2 (13) NOT NULL,
	PRIMARY KEY (DEPTNO),
	UNIQUE (DNAME)
);

SELECT *
	FROM DEP1;


CREATE TABLE EMP1 (
	EMPNO		NUMBER (4) PRIMARY KEY,
	ENAME 		VARCHAR2 (10) NOT NULL,
	JOB				VARCHAR2 (9) NOT NULL,
	MGR			NUMBER (4),
	HIREDATE 	DATE DEFAULT SYSDATE,
	SAL				NUMBER (7, 2) CHECK (SAL>0),
	COMM			NUMBER (7, 2),
	DEPTNO		NUMBER (2) REFERENCES DEPT1 (DEPTNO) -- 외래키 제약조건
	-- FOREIGN KEY(DEPTNO) REFERENCES DEPT1 (DEPTNO)
);

DROP TABLE EMP1;

SELECT *
	FROM EMP1;

INSERT INTO DEPT1
	SELECT *
		FROM DEPT;
	
INSERT INTO DEPT1 (DEPTNO, DNAME, LOC)
	VALUES (50, 'IT', 'MAPO');

INSERT INTO DEPT1 (DEPTNO, DNAME, LOC)
	VALUES (60, 'PLANNING', 'MAPO');

--	EMP, PK, NOT NULL, DEFAULT, CHECK
INSERT INTO EMP1 (EMPNO, ENAME, JOB, SAL, COMM, DEPTNO)
	VALUES (1001, 'KIM', 'MANAGER', 9000, 9000, 50);

SELECT *
	FROM EMP1;

INSERT INTO EMP1 (EMPNO, ENAME, JOB, DEPTNO)
	VALUES (1001, 'PARK', 'MANAGER', 60); -- PK 제약조건 위반

INSERT INTO EMP1 (EMPNO, JOB, DEPTNO)
	VALUES (1001, 'MANAGER', 60); -- NOT NULL 제약 조건 위반

INSERT INTO EMP1 (EMPNO, ENAME, JOB, SAL, DEPTNO)
	VALUES (1004, 'YUN', 'MANAGER', 0, 30); -- CHECK 제약 조건 위반

SELECT *
	FROM DEPT1;

INSERT INTO EMP1 (EMPNO, ENAME, JOB, DEPTNO)
	VALUES (1005, 'YI', 'MANAGER', 80); -- 외래키 제약조건

-- ◆ 연습문제 exERD로 설계 후 테이블 구성해보기
CREATE TABLE BOOKCATEGORY (
	CATEGORYCODE 	NUMBER (4) PRIMARY KEY,
	CATEGORYNAME 	VARCHAR (20) UNIQUE,
	OFFICE_LOC 		VARCHAR2 (50) NOT NULL
);

SELECT *
	FROM BOOKCATEGORY;

CREATE TABLE BOOK (
	CATERGORYCODE 	NUMBER (4) REFERENCES BOOKCATEGORY (CATEGORYCODE),
	bookNO 						VARCHAR2 (8) PRIMARY KEY,
	bookNAME					VARCHAR2 (16) NOT NULL,
	PUBLISHER					VARCHAR2 (16),
	PUBYEWAR					DATE DEFAULT SYSDATE
);


-- ◆ 연습문제 2 (목요일 시험 예상문제)
CREATE TABLE  MAJOR (
	MAJOR_CODE NUMBER (3) PRIMARY KEY,
	MAJOR_NAME VARCHAR (30) UNIQUE,
	MAJOR_OFFICE VARCHAR2 (50) NOT NULL
);
	
INSERT INTO MAJOR
	VALUES (1, '경영정보', '3층 인문실');
	
INSERT INTO MAJOR
	VALUES (2, '소프트웨어공학', '3층 인문실');	
	
INSERT INTO MAJOR
	VALUES (3, '디자인', '4층 과학실');	
	
INSERT INTO MAJOR
	VALUES (4, '경제', '4층 과학실');	
	
SELECT *
	FROM MAJOR;
	
CREATE TABLE STUDENT (
	student_code VARCHAR (4) PRIMARY KEY,
	student_NAME VARCHAR (10) NOT NULL,
	SCORE NUMBER (4) CHECK (SCORE >=0 AND SCORE <= 100),
	MAJOR_CODE NUMBER (3) REFERENCES MAJOR (MAJOR_CODE)
);
	
INSERT INTO STUDENT
	VALUES ('A01', '김길동', 100, 1);

INSERT INTO STUDENT
	VALUES ('A02', '문길동', 90, 2);

INSERT INTO STUDENT
	VALUES ('A03', '홍길동', 95, 1);




	
	
	
	